\documentclass[a4paper,12pt]{article}     %页面大小和字体大小
\usepackage{ctex}
\usepackage{geometry}
\usepackage{mathptmx}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\geometry{left=2.0cm, right=2.0cm, top=3.0cm, bottom=3.0cm}   %页边距
\linespread{1.5}      %行距

\begin{document}

\begin{center}   %居中设置
孟澍 \ 3210101819
\end{center}

\noindent %顶格（不缩进）
\textbf{1.9}\\
Yes. If we can use the natural language to describe a algorithm such that each step is percisely stated and can be carried out by a computer, and the procedure is guaranteed to terminate, we can use this form to describe an algorithm. \\

~\\
\textbf{1.11}\\
Definitieness: add proper salt to your meal.\\
Effective computability: find the largest positive number.\\
Finiteness: \verb|while(1) printf("hello world!");| This procedure will repeat forever.\\

~\\
\textbf{1.16}\\
Opcodes, data types, and addressing modes.\\

~\\
\textbf{1.18}\\
A single microarchitecture can normally implement one ISA. Many microarchitectures could exist for a single ISA.\\

~\\
\textbf{2.8}\\
a. \ $(01111111)_2 = 127.$\\
b. \ $(10000000)_2 = -128.$\\
c. \ $2^{n-1}-1.$\\
d. \ $-2^{n-1}.$\\

~\\
\textbf{2.14}\\
a. \ \verb|1100|.\\
b. \ \verb|1010|.\\
c. \ \verb|1111|.\\
d. \ \verb|1011|.\\
e. \ \verb|10000|.\\

~\\
\textbf{2.22}\\
\verb|0111111111111111| and \verb|0000000000000001|.\\

~\\
\textbf{2.24}\\
\verb|1111111111111111| and \verb|0000000000000001|.\\

~\\
\textbf{2.27}\\
Yes, there is a problem. The 2's complement number 0101010101010101 is 21845 in decimal. The 2's complement number 0011100111001111 is 14799 in decimal. We have $21845 + 14799 = 36644$. But the largest positive number one can represent in 16-bit 2's complement code is 32767. The overflow happened, so the sum these two positive integer is negative.\\

~\\
\textbf{2.34}\\
a. \ \verb|0111|.\\
b. \ \verb|0111|.\\
c. \ \verb|1101|.\\
d. \ \verb|0110|.\\
\end{document}